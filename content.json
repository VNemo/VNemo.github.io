{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"https://noobnemo.live","root":"/"},"pages":[],"posts":[{"title":"I/O Library","slug":"I-O-Library","date":"2022-10-30T11:05:32.000Z","updated":"2022-10-30T11:05:56.314Z","comments":true,"path":"2022/10/30/I-O-Library/","link":"","permalink":"https://noobnemo.live/2022/10/30/I-O-Library/","excerpt":"","text":"stdio.h当使用标准 I&#x2F;O 库函数打开或创建一个文件时，会返回一个指向 FILE 类型对象的指针（FILE *），使用该 FILE 指针与被打开或创建的文件相关联，然后该 FILE 指针就用于后续的标准 I&#x2F;O 操作（使用标准 I&#x2F;O 库函数进行 I&#x2F;O 操作），所以由此可知，FILE 指针的作用相当于文件描述符.FILE 是一个结构体数据类型，它包含了标准 I&#x2F;O 库函数为管理文件所需要的所有信息. fopen()&amp;ensp;functionThe fopen() function opens the file whose name is the string pointed to by pathname and associates a stream with it. #include &lt;stdio.h&gt; FILE *fopen(const char *pathname, const char *mode); fclose()&amp;ensp;functionThe fclose() function flushes the stream pointed to by stream (writing any buffered output data using fflush(3)) and closes the underlying file descriptor. #include &lt;stdio.h&gt; int fclose(FILE *stream); fread()&amp;ensp;function and fwrite() functionThe function fread() reads nmemb items of data, each size bytes long, from the stream pointed to by stream, storing them at the location given by ptr.The function fwrite() writes nmemb items of data, each size bytes long, to the stream pointed to by stream, obtaining them from the location given by ptr. #include &lt;stdio.h&gt; size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream); size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream); fseek()&amp;ensp;function The fseek() function sets the file position indicator for the stream pointed to by stream. The new position, measured in bytes, is obtained by adding offset bytes to the position specified bywhence. If whence is set to SEEK_SET, SEEK_CUR, or SEEK_END, the offset is relative to the start of the file, the current position indicator, or end-of-file, respectively. A successful call to the fseek() function clears the end-of-file indicator for the stream and undoes any effects of the ungetc(3) function on the samestream. #include &lt;stdio.h&gt; int fseek(FILE *stream, long offset, int whence); ftell()&amp;ensp;functionThe ftell() function obtains the current value of the file position indicator for the stream pointed to by stream. #include &lt;stdio.h&gt; int fseek(FILE *stream, long offset, int whence); long ftell(FILE *stream); clearerr()&amp;ensp;functionThe function clearerr() clears the end-of-file and error indicators for the stream pointed to by stream. #include &lt;stdio.h&gt; void clearerr(FILE *stream); snprintf()&amp;ensp;functionThe functions snprintf() and vsnprintf() write at most size bytes (including the terminating null byte (‘\\0’)) to str. #include &lt;stdio.h&gt; int snprintf(char *str, size_t size, const char *format, ...); I&#x2F;O cacheread()和 write()系统调用在进行文件读写操作的时候并不会直接访问磁盘设备，而是仅仅在用户空间缓冲区和内核缓冲区（kernel buffer cache）之间复制数据。 fsync()&amp;ensp;functionfsync() transfers (“flushes”) all modified in-core data of (i.e., modified buffer cache pages for) the file referred to by the file descriptor fd to the disk device (or other permanent storage device) so that all changed information can be retrieved even if the system crashes or is rebooted. #include &lt;unistd.h&gt; int fsync(int fd); sync()&amp;ensp;functionLinux command sync #include &lt;unistd.h&gt; void sync(void); Dirct I&#x2F;O (raw I&#x2F;O)我们可针对某一文件或块设备执行直接 I&#x2F;O，要做到这一点，需要在调用 open()函数打开文件时，指定O_DIRECT 标志，该标志至 Linux 内核 2.4.10 版本开始生效，譬如： fd = open(filepath, O_WRONLY | O_DIRECT); 因为直接 I&#x2F;O 涉及到对磁盘设备的直接访问，所以在执行直接 I&#x2F;O 时，必须要遵守以下三个对齐限制要求：⚫ 应用程序中用于存放数据的缓冲区，其内存起始地址必须以块大小的整数倍进行对齐；⚫ 写文件时，文件的位置偏移量必须是块大小的整数倍；⚫ 写入到文件的数据大小必须是块大小的整数倍。 *Raw I&#x2F;O因为直接 I&#x2F;O 涉及到对磁盘设备的直接访问，所以在执行直接 I&#x2F;O 时，必须要遵守以下三个对齐限制要求：⚫ 应用程序中用于存放数据的缓冲区，其内存起始地址必须以块大小的整数倍进行对齐；⚫ 写文件时，文件的位置偏移量必须是块大小的整数倍；⚫ 写入到文件的数据大小必须是块大小的整数倍。 setvbuf()&amp;ensp;functionThe three types of buffering available are unbuffered, block buffered, and line buffered. When an output stream is unbuffered, information appears on the destination file or terminal as soon aswritten; when it is block buffered many characters are saved up and written as a block; when it is line buffered characters are saved up until a newline is output or input is read from any streamattached to a terminal device (typically stdin). The function fflush(3) may be used to force the block out early.Normally all files are block buffered. _IONBF unbuffered _IOLBF line buffered //(default) _IOFBF fully buffered fflush()&amp;ensp;functionFor output streams, fflush() forces a write of all user-space buffered data for the given output or update stream via the stream’s underlying write function. For input streams associated with seekable files (e.g., disk files, but not pipes or terminals), fflush() discards any buffered data that has been fetched from the underlying file, but has not been consumed by the application. #include &lt;stdio.h&gt; int fflush(FILE *stream); Another way to flush thefclose(stdout); fdopen()&amp;ensp;and fileno() functionThe fdopen() function associates a stream with the eqxisting file descriptor, fd.The function fileno() examines the argument stream and returns the integer file descriptor used to implement this stream. The file descriptor is still owned by stream and will be closed when fclose(3) is called. Duplicate the file descriptor with dup(2) before passing it to code that might close it. #include &lt;stdio.h&gt; int fileno(FILE *stream); FILE *fdopen(int fd, const char *mode); ┌─────────────┬───────────────────────────────┐ │fopen() mode │ open() flags │ ├─────────────┼───────────────────────────────┤ │ r │ O_RDONLY │ ├─────────────┼───────────────────────────────┤ │ w │ O_WRONLY | O_CREAT | O_TRUNC │ ├─────────────┼───────────────────────────────┤ │ a │ O_WRONLY | O_CREAT | O_APPEND │ ├─────────────┼───────────────────────────────┤ │ r+ │ O_RDWR │ ├─────────────┼───────────────────────────────┤ │ w+ │ O_RDWR | O_CREAT | O_TRUNC │ ├─────────────┼───────────────────────────────┤ │ a+ │ O_RDWR | O_CREAT | O_APPEND │ └─────────────┴───────────────────────────────┘","categories":[],"tags":[]},{"title":"I/O basic","slug":"I-O-basic","date":"2022-10-30T11:03:21.000Z","updated":"2022-10-30T11:03:43.460Z","comments":true,"path":"2022/10/30/I-O-basic/","link":"","permalink":"https://noobnemo.live/2022/10/30/I-O-basic/","excerpt":"","text":"File I&#x2F;O Basics文件描述符（file descriptor）调用 open 函数会有一个返回值，函数执行成功的情况下，会返回一个非负整数，该返回值就是一个文件描述符(file descriptor)，对于 Linux 内核而言，所有打开的文件都会通过文件描述符进行索引。一个进程可以打开多个文件，但是在 Linux 系统中，一个进程可以打开的文件数是有限制，并不是可以无限制打开很多的文件，可以通过 ulimit 命令来查看进程可打开的最大文件数: ulimit -n 所以对于一个进程来说，文件描述符是一种有限资源，文件描述符是从 0 开始分配的，每一个被打开的文件在同一个进程中都有一个唯一的文件描述符，不会重复，如果文件被关闭后，它对应的文件描述符将会被释放，那么这个文件描述符将可以再次分配给其它打开的文件、与对应的文件绑定起来,每次给打开的文件分配文件描述符都是从最小的没有被使用的文件描述符（0~1023）开始，如果文件被关闭后，它对应的文件描述符将会被释放.调用 open 函数打开文件的时候，分配的文件描述符一般都是从 3 开始，0、1、2 这三个文件描述符已经默认被系统占用了，分别分配给了系统标准输入（0）、标准输出（1）以及标准错误（2）. open()&amp;ensp;function #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; int open(const char *pathname, int flags); int open(const char *pathname, int flags, mode_t mode); The argument flags must include one of the following access modes: O_RDONLY, O_WRONLY, or O_RDWR. These request opening the file read-only, write-only, or read&#x2F;write, respectively. O_APPEND,the file offset is positioned at the end of the file.O_TRUNC,If the file already exists and is a regular file and the access mode allows writing (i.e., is O_RDWR or O_WRONLY) it will be truncated to length 0. The following symbolic constants are provided for mode: S_IRWXU 00700 user (file owner) has read, write, and execute permission S_IRUSR 00400 user has read permission S_IWUSR 00200 user has write permission S_IXUSR 00100 user has execute permission S_IRWXG 00070 group has read, write, and execute permission S_IRGRP 00040 group has read permission S_IWGRP 00020 group has write permission S_IXGRP 00010 group has execute permission S_IRWXO 00007 others have read, write, and execute permission S_IROTH 00004 others have read permission S_IWOTH 00002 others have write permission S_IXOTH 00001 others have execute permission According to POSIX, the effect when other bits are set in mode is unspecified. On Linux, the following bits are also honored in mode: S_ISUID 0004000 set-user-ID bit S_ISGID 0002000 set-group-ID bit (see inode(7)). S_ISVTX 0001000 sticky bit (see inode(7)). 可以通过位或运算将多个宏组合在一起 S_IRUSR | S_IWUSR | S_IROTH write()&amp;ensp;functionwrite() writes up to count bytes from the buffer starting at buf to the file referred to by the file descriptor fd. #include &lt;unistd.h&gt; ssize_t write(int fd, const void *buf, size_t count); On success, the number of bytes written is returned. On error, -1 is returned read()&amp;ensp;functionread() attempts to read up to count bytes from file descriptor fd into the buffer starting at buf. #include &lt;unistd.h&gt; ssize_t read(int fd, void *buf, size_t count); lseek()&amp;ensp;function lseek() repositions the file offset of the open file description associated with the file descriptor fd to the argument offset according to the directive whence. #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt; off_t lseek(int fd, off_t offset, int whence); SEEK_SET The file offset is set to offset bytes. SEEK_CUR The file offset is set to its current location plus offset bytes. SEEK_END The file offset is set to the size of the file plus offset bytes. Static files and inodeStatic files are files that don’t change when your application is running.，硬盘的最小存储单位叫做“扇区”（Sector），每个扇区储存 512 字节（相当于 0.5KB），操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个“块”（block）。这种由多个扇区组成的“块”，是文件存取的最小单位。“块”的大小，最常见的是 4KB，即连续八个 sector 组成一个 block。所以由此可以知道，静态文件对应的数据都是存储在磁盘设备不同的“块”中.我们的磁盘在进行分区、格式化的时候会将其分为两个区域，一个是数据区，用于存储文件中的数据；另一个是 inode 区，用于存放 inode table（inode 表），inode table 中存放的是一个一个的 inode（也成为 inode节点），不同的 inode 就可以表示不同的文件，每一个文件都必须对应一个 inode，inode 实质上是一个结构体，这个结构体中有很多的元素，不同的元素记录了文件了不同信息，譬如文件字节大小、文件所有者、文件对应的读&#x2F;写&#x2F;执行权限、文件时间戳（创建时间、更新时间等）、文件类型、文件数据存储的 block（块）位置等等信息.inode table 表本身也需要占用磁盘的存储空间。每一个文件都有唯一的一个 inode，每一个 inode 都有一个与之相对应的数字编号，通过这个数字编号就可以找到 inode table 中所对应的 inode。 //Check inode number: ls -i //or stat filename 打开一个文件，系统内部会将这个过程分为三步： 系统找到这个文件名所对应的 inode 编号； 通过 inode 编号从 inode table 中找到对应的 inode 结构体； 根据 inode 结构体中记录的信息，确定文件数据所在的 block，并读出数据。 strerror()&amp;ensp;functionThe strerror() function returns a pointer to a string that describes the error code passed in the argument errnum. #include &lt;string.h&gt; char *strerror(int errnum); // strerror(errno);need to include &lt;stdbool.h&gt; use “man errno” to check list of error names. perror()&amp;ensp;functionThe perror() function produces a message on standard error describing the last error encountered during a call to a system or library function. #include &lt;stdio.h&gt; void perror(const char *s); exit()、_exit()and_Exit()调用_exit()函数会清除其使用的内存空间，并销毁其在内核中的各种数据结构，关闭进程的所有文件描述符，并结束进程、将控制权交给操作系统。 #include &lt;unistd.h&gt; void _exit(int status); #include &lt;stdlib.h&gt; void _Exit(int status); #include &lt;stdlib.h&gt; void exit(int status); hole file&amp;ensp;空洞文件在Linux中，lseek的系统调用是可以改变在文件上面的偏移量的，而且还允许其超出文件的长度。偏移量一旦超出了文件的长度，下一次进行文件IO写入操作文件的时候便会延续偏移量的位置继续写入，进而在文件中间产生了空洞的部分，这部分会以”\\0”填充，而从原来的文件结尾到新写入数据间的这段空间就被称为“文件空洞”。在Linux中，EOF（文件结束符）并不是一个字符，而是在读取到文件末尾的时候返回的一个信号值，也就是-1。文件空洞部分实际上是不会占用任何的物理空间的，直到在某个时刻对空洞部分进行写入文件内容的时候才会为它分配对应的空间。但是在空洞文件形成的时候，逻辑上面的文件大小是分配了空洞部分的大小的。空洞文件对多线程共同操作文件是及其有用的，有时候我们创建一个很大的文件，如果单个线程从头开始依次构建该文件需要很长的时间，有一种思路就是将文件分为多段，然后使用多线程来操作，每个线程负责其中一段数据的写入. ##多次打开同一个文件## 一个进程内多次 open 打开同一个文件，在内存中并不会存在多份动态文件。 一个进程内多次 open 打开同一个文件，不同文件描述符所对应的读写位置偏移量是相互独立的。 在 Linux 系统中，open 返回得到的文件描述符 fd 可以进行复制，复制成功之后可以得到一个新的文件描述符，使用新的文件描述符和旧的文件描述符都可以对文件进行 IO 操作，复制得到的文件描述符和旧的文件描述符拥有相同的权限.“复制”的含义实则是复制文件表。 dup()&amp;ensp;functionThe dup() system call creates a copy of the file descriptor oldfd, using the lowest-numbered unused file descriptor for the new descriptor. After a successful return, the old and new file descriptors may be used interchangeably. #include &lt;unistd.h&gt; int dup(int oldfd); int dup2(int oldfd, int newfd); The dup2() system call performs the same task as dup(), but instead of using the lowest-numbered unused file descriptor, it uses the file descriptor number specified in newfd. If the file descrip‐tor newfd was previously open, it is silently closed before being reused. atomicity operating and race conditions(race hazards)All system calls are executed atomically. By this, we mean that the kernel guarantees that all of the steps in a system call are completed as a single operation, without being interrupted by another process or thread.Arace condition is a situation where the result produced by two processes (or threads) operating on shared resources depends in an unexpected way on the rela-tive order in which the processes gain access to the CPU(s).每个进程（或线程）去操作文件的顺序是不可预期的，即这些进程获得 CPU 使用权的先后顺序是不可预期的，完全由操作系统调配，这就是所谓的竞争状态。所谓原子操作，是有多步操作组成的一个操作，原子操作要么一步也不执行，一旦执行，必须要执行完所有步骤，不可能只执行所有步骤中的一个子集。Flag:O_APPEND.当 open 函数的 flags 参数中包含了 O_APPEND 标志，每次执行 write 写入操作时都会将文件当前写位置偏移量移动到文件末尾，然后再写入数据，这里“移动当前写位置偏移量到文件末尾、写入数据”这两个操作步骤就组成了一个原子操作.将“判断文件是否存在、创建文件”这两个步骤合成为一个原子操作，有了原子操作 pread()&amp;ensp; and pwrite() functionpread() reads up to count bytes from file descriptor fd at offset off‐set (from the start of the file) into the buffer starting at buf. Thefile offset is not changed.pwrite() writes up to count bytes from the buffer starting at buf to the file descriptor fd at offset offset. The file offset is not changed. #include &lt;unistd.h&gt; ssize_t pread(int fd, void *buf, size_t count, off_t offset); ssize_t pwrite(int fd, const void *buf, size_t count, off_t offset); The pread() and pwrite() system calls are especially useful in multi‐threaded applications. They allow multiple threads to perform I&#x2F;O on the same file descriptor without being affected by changes to the fileoffset by other threads Difference between Process and ThreadProcess(进程): Processes are basically the programs that are dispatched from the ready state and are scheduled in the CPU for execution. PCB(Process Control Block) holds the concept of process. A process can create other processes which are known as Child Processes. The process takes more time to terminate and it is isolated means it does not share the memory with any other process.The process can have the following states new, ready, running, waiting, terminated, and suspended. Thread(线程): Thread is the segment of a process which means a process can have multiple threads and these multiple threads are contained within a process. A thread has three states: Running, Ready, and Blocked. The thread takes less time to terminate as compared to the process but unlike the process, threads do not isolate. fcntl()&amp;ensp;function and ioctl() functionfcntl()&amp;ensp;performs one of the operations described below on the open file descriptor fd. The operation is determined by cmd. #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; int fcntl(int fd, int cmd, ... /* arg */ ); The ioctl() system call manipulates the underlying device parameters of special files. In particular, many operating characteristics of character special files (e.g., terminals) may be controlled with ioctl() requests. The argument fd must be an open file descriptor. #include &lt;sys/ioctl.h&gt; int ioctl(int fd, unsigned long request, ...); File Truncation,truncate()&amp;ensp;function and ftruncate() fucntion#include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; int truncate(const char *path, off_t length); int ftruncate(int fd, off_t length); Reference [1]https://banbanpeppa.github.io/2019/08/21/linux/holefile/[2]linux man document[3]https://www.geeksforgeeks.org/difference-between-process-and-thread/","categories":[],"tags":[]},{"title":"Meaning of man page numbers","slug":"Meaning-of-man-page-numbers","date":"2022-10-13T01:54:14.000Z","updated":"2022-10-13T01:54:38.581Z","comments":true,"path":"2022/10/13/Meaning-of-man-page-numbers/","link":"","permalink":"https://noobnemo.live/2022/10/13/Meaning-of-man-page-numbers/","excerpt":"","text":"Executable programs or shell commands System calls (functions provided by the kernel) Library calls (functions within program libraries) Special files (usually found in &#x2F;dev) File formats and conventions, e.g. &#x2F;etc&#x2F;passwd Games Miscellaneous (including macro packages and conventions), e.g.man(7), groff(7), man-pages(7) System administration commands (usually only for root) Kernel routines [Non standard] comand/*display specific section of man command*/ man &lt;number&gt; man /*display every matching page*/ man -a man","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://noobnemo.live/tags/Linux/"}]},{"title":"Linux Directory","slug":"Linux-Directory","date":"2022-10-13T01:52:43.000Z","updated":"2022-10-13T01:53:02.791Z","comments":true,"path":"2022/10/13/Linux-Directory/","link":"","permalink":"https://noobnemo.live/2022/10/13/Linux-Directory/","excerpt":"","text":"Linux DirectoryContents of the Linux root directory 目录 目录放置的内容 bin 存放系统命令的目录，如命令 cat，cp，mkdir boot 存放开机启动过程所需的内容，如开机管理程序 grub2 dev 所有设备文件的目录（如声卡、硬盘、光驱） etc 系统的主要配置文件,such as &#x2F;etc&#x2F;passwd home 用户家目录数据的存放目录 lib 存放 sbin 和 bin 目录下命令所需的库文件,存放了根文件系统程序运行所需 的共享文件。如 C 语言标准库。 lib32&#x2F;lib64 存放二进制函数库，支持 32 位&#x2F;64 位 lost+found 在 EXT3&#x2F;4 系统中，当系统意外崩溃或意外关机时，会产生一些碎片文件在这个目录下面，系统启动 fcsk 工具会检查这个目录，并修复已损坏的文件。 media 用于挂载光盘，软盘和 DVD 等设备 mnt 同 media 作用一样，用于临时挂载存储设备 opt 第三方软件安装存放目录。 proc 进程及内核信息存放目录，不占用硬盘空间。 root root 用户的家目录 run 是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件 应该被删掉或清除。 sbinroot 用户使用的命令存放目录 srv 一些网络服务所需要的数据文件 sys 同 proc 目录，用于记录 CPU 与系统硬件的相关信息 tmp 程序运行时产生的临时文件存放目录 usr 系统存放程序的目录，类似于在 windows 下的文件夹 programeﬁles var 存放内容常变动的文件目录，如系统日志文件 &#x2F;bin &#x2F;bin 目录是&#x2F;binary 的缩写，它包含众多普通用户可用的命令。而命令的本质就是可执行程序，即二进制 bin 文件。 &#x2F;sbin &#x2F;sbin 目录是&#x2F;system bin 的缩写，它的功能类似&#x2F;bin ，不过它存储的一般是系统程序，一般需要使用管理员权限才能使用。ex.sysctl,fdisk,poweroff. &#x2F;etc &#x2F;etc 目录是&#x2F;etcetera 的缩写，据说原始的 Unix 设计是在该目录存放些零碎的内容，但现在该目录现在已发展成存放系统的各种配置文件，非常重要。如用户信息文件&#x2F;etc&#x2F;passwd，系统初始化文件&#x2F;etc&#x2F;rc 等，系统依据这些配置运行。 &#x2F;root &#x2F;root 是超级用户的目录，在 Ubuntu 下默认为空。 &#x2F;home storage users’ files, it contians documents, downloads, pictures, public files etc. &#x2F;lib &#x2F;lib 目录是&#x2F;library 的缩写，根文件系统上的程序所需的共享库，存放了根文件系统程序运行所需的共享文件。如 C 语言标准库，这些文件包含了可被许多程序共享的代码，以避免每个程序都包含有相同的子程序的副本，故可以使得可执行文件变得更小，节省空间。 &#x2F;dev &#x2F;dev 目录存放了设备文件，即设备驱动程序，用户通过这些文件访问外部设备。 &#x2F;proc &#x2F;proc 目录通常包含了内核导出到用户空间的内核信息，通过访问该目录下的文件可以查看这些信息。 sys 与&#x2F;proc 目录类似，&#x2F;sys 目录用于把内核的设备驱动导出到用户空间，可通过访问 sys 目录及其下的文件，来查看甚至控制内核的一些驱动设备。 &#x2F;tmp &#x2F;tmp 目录存放程序在运行时产生的信息和数据。但在引导启动后，运行的程序最好使用&#x2F;var&#x2F;tmp来代替&#x2F;tmp，因为前者可能拥有一个更大的磁盘空间。 &#x2F;boot &#x2F;boot 目录存放引导加载器 (bootstrap loader) 使用的文件，如 lilo，核心映像也经常放在这里，而不是放在根目录中。 &#x2F;mnt &#x2F;mnt 目录是系统管理员临时挂载 (mount) 文件系统的安装点。 &#x2F;media &#x2F;media 目录通常是一些自动挂载的设备目录，如光盘和 U 盘，部分系统会自动挂载到这个目录下，然后通过自动挂载的目录可以访问对应的设备。 &#x2F;usr &#x2F;usr 只专门存放各种程序和数据,其含义已经从“用户目录”变成了“unixsystem resource” Two type of links symbolic links : (also known as “soft links” or “symlinks”): Refer to a symbolic path indicating the abstract location of another file.Soft links are similar to shortcuts, and can point to another file or directory in any file system. hard links : Refer to the specific location of physical data.Hard links are also shortcuts for files and folders, but a hard link cannot be created for a folder or file in a different file system. Difference between the two type : These links behave differently when the source of the link (what is being linked to) is moved or removed. Symbolic links are not updated (they merely contain a string which is the path name of its target); hard links always refer to the source, even if moved or removed. Reference [1]野火 Linux 基础与应用开发实战指南[2]https://www.cyberciti.biz/faqcreating-soft-link-or-symbolic-link/[3]https://www.freecodecamp.org/newssymlink-tutorial-in-linux-how-to-create-and-remove-a-symbolic-link/[4]https://www.geeksforgeeks.org/soft-hard-links-unixlinux/","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://noobnemo.live/tags/Linux/"}]},{"title":"C语言常用数据类型打印转换字符","slug":"C语言常用数据类型打印转换字符","date":"2022-10-13T01:51:48.000Z","updated":"2022-10-13T01:52:09.062Z","comments":true,"path":"2022/10/13/C语言常用数据类型打印转换字符/","link":"","permalink":"https://noobnemo.live/2022/10/13/C%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%89%93%E5%8D%B0%E8%BD%AC%E6%8D%A2%E5%AD%97%E7%AC%A6/","excerpt":"","text":"常用数据类型打印转换字符 数据类型 转换字符（转换说明） short %h int %d unsigned int %u long %ld unsigned long %lu long long %lld unsigned long long %llu float %f double %f scientific notation %e char %c Octal %o Hexadecimal %x Octal prefix %#o Hexadecimal prefix %#x pointer %p","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://noobnemo.live/tags/Linux/"}]},{"title":"hello world","slug":"hello-world","date":"2022-10-03T07:53:21.000Z","updated":"2022-10-03T08:34:39.952Z","comments":true,"path":"2022/10/03/hello-world/","link":"","permalink":"https://noobnemo.live/2022/10/03/hello-world/","excerpt":"","text":"Hello Worldtitletitle","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://noobnemo.live/tags/Linux/"}]}